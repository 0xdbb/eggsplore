// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: accounts.sql

package database

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const clearAccountOTP = `-- name: ClearAccountOTP :exec
UPDATE "accounts"
SET otp_code = NULL,
    otp_expires_at = NULL,
    updated_at = now()
WHERE id = $1
`

func (q *Queries) ClearAccountOTP(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, clearAccountOTP, id)
	return err
}

const createAccount = `-- name: CreateAccount :one
INSERT INTO "accounts" (
    email, first_name, last_name, department,role, status, signup_token, signup_token_expires_at
) VALUES (
    $1, $2, $3, $4, $5, 'PENDING', $6, $7
)
RETURNING id, first_name, last_name, user_name, email, department, password, status, role, is_2fa_enabled, signup_token, signup_token_expires_at, otp_code, otp_expires_at, is_approved, created_at, last_active, updated_at, profile_url
`

type CreateAccountParams struct {
	Email                string      `json:"email"`
	FirstName            pgtype.Text `json:"first_name"`
	LastName             pgtype.Text `json:"last_name"`
	Department           string      `json:"department"`
	Role                 string      `json:"role"`
	SignupToken          pgtype.Text `json:"signup_token"`
	SignupTokenExpiresAt pgtype.Text `json:"signup_token_expires_at"`
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) (Accounts, error) {
	row := q.db.QueryRow(ctx, createAccount,
		arg.Email,
		arg.FirstName,
		arg.LastName,
		arg.Department,
		arg.Role,
		arg.SignupToken,
		arg.SignupTokenExpiresAt,
	)
	var i Accounts
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.UserName,
		&i.Email,
		&i.Department,
		&i.Password,
		&i.Status,
		&i.Role,
		&i.Is2faEnabled,
		&i.SignupToken,
		&i.SignupTokenExpiresAt,
		&i.OtpCode,
		&i.OtpExpiresAt,
		&i.IsApproved,
		&i.CreatedAt,
		&i.LastActive,
		&i.UpdatedAt,
		&i.ProfileUrl,
	)
	return i, err
}

const deleteAccount = `-- name: DeleteAccount :exec
DELETE FROM "accounts"
WHERE id = $1
`

func (q *Queries) DeleteAccount(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAccount, id)
	return err
}

const getAccount = `-- name: GetAccount :one
SELECT id, first_name, last_name, user_name, email, department, password, status, role, is_2fa_enabled, signup_token, signup_token_expires_at, otp_code, otp_expires_at, is_approved, created_at, last_active, updated_at, profile_url FROM "accounts"
WHERE id = $1
`

func (q *Queries) GetAccount(ctx context.Context, id uuid.UUID) (Accounts, error) {
	row := q.db.QueryRow(ctx, getAccount, id)
	var i Accounts
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.UserName,
		&i.Email,
		&i.Department,
		&i.Password,
		&i.Status,
		&i.Role,
		&i.Is2faEnabled,
		&i.SignupToken,
		&i.SignupTokenExpiresAt,
		&i.OtpCode,
		&i.OtpExpiresAt,
		&i.IsApproved,
		&i.CreatedAt,
		&i.LastActive,
		&i.UpdatedAt,
		&i.ProfileUrl,
	)
	return i, err
}

const getAccountByEmail = `-- name: GetAccountByEmail :one
SELECT id, first_name, last_name, user_name, email, department, password, status, role, is_2fa_enabled, signup_token, signup_token_expires_at, otp_code, otp_expires_at, is_approved, created_at, last_active, updated_at, profile_url FROM "accounts"
WHERE LOWER(email) = LOWER($1)
`

func (q *Queries) GetAccountByEmail(ctx context.Context, lower string) (Accounts, error) {
	row := q.db.QueryRow(ctx, getAccountByEmail, lower)
	var i Accounts
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.UserName,
		&i.Email,
		&i.Department,
		&i.Password,
		&i.Status,
		&i.Role,
		&i.Is2faEnabled,
		&i.SignupToken,
		&i.SignupTokenExpiresAt,
		&i.OtpCode,
		&i.OtpExpiresAt,
		&i.IsApproved,
		&i.CreatedAt,
		&i.LastActive,
		&i.UpdatedAt,
		&i.ProfileUrl,
	)
	return i, err
}

const getAccountByResetToken = `-- name: GetAccountByResetToken :one
SELECT id, first_name, last_name, user_name, email, password, role, department, created_at, updated_at, status, signup_token, signup_token_expires_at, otp_code, otp_expires_at
FROM "accounts"
WHERE signup_token = $1
`

type GetAccountByResetTokenRow struct {
	ID                   uuid.UUID   `json:"id"`
	FirstName            pgtype.Text `json:"first_name"`
	LastName             pgtype.Text `json:"last_name"`
	UserName             pgtype.Text `json:"user_name"`
	Email                string      `json:"email"`
	Password             pgtype.Text `json:"password"`
	Role                 string      `json:"role"`
	Department           string      `json:"department"`
	CreatedAt            time.Time   `json:"created_at"`
	UpdatedAt            time.Time   `json:"updated_at"`
	Status               string      `json:"status"`
	SignupToken          pgtype.Text `json:"signup_token"`
	SignupTokenExpiresAt pgtype.Text `json:"signup_token_expires_at"`
	OtpCode              pgtype.Text `json:"otp_code"`
	OtpExpiresAt         pgtype.Text `json:"otp_expires_at"`
}

func (q *Queries) GetAccountByResetToken(ctx context.Context, signupToken pgtype.Text) (GetAccountByResetTokenRow, error) {
	row := q.db.QueryRow(ctx, getAccountByResetToken, signupToken)
	var i GetAccountByResetTokenRow
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.UserName,
		&i.Email,
		&i.Password,
		&i.Role,
		&i.Department,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.SignupToken,
		&i.SignupTokenExpiresAt,
		&i.OtpCode,
		&i.OtpExpiresAt,
	)
	return i, err
}

const getAccountBySignupToken = `-- name: GetAccountBySignupToken :one
SELECT id, first_name, last_name, user_name, email, department, password, status, role, is_2fa_enabled, signup_token, signup_token_expires_at, otp_code, otp_expires_at, is_approved, created_at, last_active, updated_at, profile_url FROM "accounts"
WHERE signup_token = $1
`

func (q *Queries) GetAccountBySignupToken(ctx context.Context, signupToken pgtype.Text) (Accounts, error) {
	row := q.db.QueryRow(ctx, getAccountBySignupToken, signupToken)
	var i Accounts
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.UserName,
		&i.Email,
		&i.Department,
		&i.Password,
		&i.Status,
		&i.Role,
		&i.Is2faEnabled,
		&i.SignupToken,
		&i.SignupTokenExpiresAt,
		&i.OtpCode,
		&i.OtpExpiresAt,
		&i.IsApproved,
		&i.CreatedAt,
		&i.LastActive,
		&i.UpdatedAt,
		&i.ProfileUrl,
	)
	return i, err
}

const getAccountMetrics = `-- name: GetAccountMetrics :one
SELECT
    COUNT(*) AS total_accounts,
    SUM(CASE WHEN status = 'ACTIVE' THEN 1 ELSE 0 END) AS active_users,
    SUM(CASE WHEN status = 'INACTIVE' THEN 1 ELSE 0 END) AS inactive_users,
    SUM(CASE WHEN status = 'PENDING' THEN 1 ELSE 0 END) AS pending_invites
FROM accounts
`

type GetAccountMetricsRow struct {
	TotalAccounts  int64 `json:"total_accounts"`
	ActiveUsers    int64 `json:"active_users"`
	InactiveUsers  int64 `json:"inactive_users"`
	PendingInvites int64 `json:"pending_invites"`
}

func (q *Queries) GetAccountMetrics(ctx context.Context) (GetAccountMetricsRow, error) {
	row := q.db.QueryRow(ctx, getAccountMetrics)
	var i GetAccountMetricsRow
	err := row.Scan(
		&i.TotalAccounts,
		&i.ActiveUsers,
		&i.InactiveUsers,
		&i.PendingInvites,
	)
	return i, err
}

const listAccounts = `-- name: ListAccounts :many
SELECT id, first_name, last_name, user_name, email, department, password, status, role, is_2fa_enabled, signup_token, signup_token_expires_at, otp_code, otp_expires_at, is_approved, created_at, last_active, updated_at, profile_url
FROM accounts
WHERE
  (($3::varchar IS NULL OR $3::varchar = '') OR role::varchar = $3::varchar)
AND (($4::varchar IS NULL OR $4::varchar = '') OR status::varchar = $4::varchar)
AND (($5::varchar IS NULL OR $5::varchar = '') OR department::varchar = $5::varchar)
LIMIT $1 OFFSET $2
`

type ListAccountsParams struct {
	Limit      int32  `json:"limit"`
	Offset     int32  `json:"offset"`
	Role       string `json:"role"`
	Status     string `json:"status"`
	Department string `json:"department"`
}

func (q *Queries) ListAccounts(ctx context.Context, arg ListAccountsParams) ([]Accounts, error) {
	rows, err := q.db.Query(ctx, listAccounts,
		arg.Limit,
		arg.Offset,
		arg.Role,
		arg.Status,
		arg.Department,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Accounts{}
	for rows.Next() {
		var i Accounts
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.UserName,
			&i.Email,
			&i.Department,
			&i.Password,
			&i.Status,
			&i.Role,
			&i.Is2faEnabled,
			&i.SignupToken,
			&i.SignupTokenExpiresAt,
			&i.OtpCode,
			&i.OtpExpiresAt,
			&i.IsApproved,
			&i.CreatedAt,
			&i.LastActive,
			&i.UpdatedAt,
			&i.ProfileUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAccountDepartment = `-- name: UpdateAccountDepartment :one
UPDATE "accounts"
SET department = $2,
    updated_at = now()
WHERE id = $1
RETURNING id, first_name, last_name, user_name, email, department, password, status, role, is_2fa_enabled, signup_token, signup_token_expires_at, otp_code, otp_expires_at, is_approved, created_at, last_active, updated_at, profile_url
`

type UpdateAccountDepartmentParams struct {
	ID         uuid.UUID `json:"id"`
	Department string    `json:"department"`
}

func (q *Queries) UpdateAccountDepartment(ctx context.Context, arg UpdateAccountDepartmentParams) (Accounts, error) {
	row := q.db.QueryRow(ctx, updateAccountDepartment, arg.ID, arg.Department)
	var i Accounts
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.UserName,
		&i.Email,
		&i.Department,
		&i.Password,
		&i.Status,
		&i.Role,
		&i.Is2faEnabled,
		&i.SignupToken,
		&i.SignupTokenExpiresAt,
		&i.OtpCode,
		&i.OtpExpiresAt,
		&i.IsApproved,
		&i.CreatedAt,
		&i.LastActive,
		&i.UpdatedAt,
		&i.ProfileUrl,
	)
	return i, err
}

const updateAccountLastActive = `-- name: UpdateAccountLastActive :exec
UPDATE "accounts"
SET last_active = now()
WHERE id = $1
`

func (q *Queries) UpdateAccountLastActive(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, updateAccountLastActive, id)
	return err
}

const updateAccountOTP = `-- name: UpdateAccountOTP :exec
UPDATE "accounts"
SET otp_code = $2,
    otp_expires_at = $3,
    updated_at = now()
WHERE id = $1
`

type UpdateAccountOTPParams struct {
	ID           uuid.UUID   `json:"id"`
	OtpCode      pgtype.Text `json:"otp_code"`
	OtpExpiresAt pgtype.Text `json:"otp_expires_at"`
}

func (q *Queries) UpdateAccountOTP(ctx context.Context, arg UpdateAccountOTPParams) error {
	_, err := q.db.Exec(ctx, updateAccountOTP, arg.ID, arg.OtpCode, arg.OtpExpiresAt)
	return err
}

const updateAccountPassword = `-- name: UpdateAccountPassword :one
UPDATE "accounts"
SET password = $2,
    signup_token = NULL,
    signup_token_expires_at = NULL,
    updated_at = now()
WHERE id = $1
RETURNING id, first_name, last_name, user_name, email, department, password, status, role, is_2fa_enabled, signup_token, signup_token_expires_at, otp_code, otp_expires_at, is_approved, created_at, last_active, updated_at, profile_url
`

type UpdateAccountPasswordParams struct {
	ID       uuid.UUID   `json:"id"`
	Password pgtype.Text `json:"password"`
}

func (q *Queries) UpdateAccountPassword(ctx context.Context, arg UpdateAccountPasswordParams) (Accounts, error) {
	row := q.db.QueryRow(ctx, updateAccountPassword, arg.ID, arg.Password)
	var i Accounts
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.UserName,
		&i.Email,
		&i.Department,
		&i.Password,
		&i.Status,
		&i.Role,
		&i.Is2faEnabled,
		&i.SignupToken,
		&i.SignupTokenExpiresAt,
		&i.OtpCode,
		&i.OtpExpiresAt,
		&i.IsApproved,
		&i.CreatedAt,
		&i.LastActive,
		&i.UpdatedAt,
		&i.ProfileUrl,
	)
	return i, err
}

const updateAccountResetToken = `-- name: UpdateAccountResetToken :exec
UPDATE "accounts"
SET signup_token = $2,
    signup_token_expires_at = $3,
    updated_at = now()
WHERE LOWER( email ) = LOWER( $1 )
`

type UpdateAccountResetTokenParams struct {
	Lower                string      `json:"lower"`
	SignupToken          pgtype.Text `json:"signup_token"`
	SignupTokenExpiresAt pgtype.Text `json:"signup_token_expires_at"`
}

func (q *Queries) UpdateAccountResetToken(ctx context.Context, arg UpdateAccountResetTokenParams) error {
	_, err := q.db.Exec(ctx, updateAccountResetToken, arg.Lower, arg.SignupToken, arg.SignupTokenExpiresAt)
	return err
}

const updateAccountRole = `-- name: UpdateAccountRole :one
UPDATE "accounts"
SET role = $2,
    updated_at = now()
WHERE id = $1
RETURNING id, first_name, last_name, user_name, email, department, password, status, role, is_2fa_enabled, signup_token, signup_token_expires_at, otp_code, otp_expires_at, is_approved, created_at, last_active, updated_at, profile_url
`

type UpdateAccountRoleParams struct {
	ID   uuid.UUID `json:"id"`
	Role string    `json:"role"`
}

func (q *Queries) UpdateAccountRole(ctx context.Context, arg UpdateAccountRoleParams) (Accounts, error) {
	row := q.db.QueryRow(ctx, updateAccountRole, arg.ID, arg.Role)
	var i Accounts
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.UserName,
		&i.Email,
		&i.Department,
		&i.Password,
		&i.Status,
		&i.Role,
		&i.Is2faEnabled,
		&i.SignupToken,
		&i.SignupTokenExpiresAt,
		&i.OtpCode,
		&i.OtpExpiresAt,
		&i.IsApproved,
		&i.CreatedAt,
		&i.LastActive,
		&i.UpdatedAt,
		&i.ProfileUrl,
	)
	return i, err
}

const updateAccountSetup = `-- name: UpdateAccountSetup :one
UPDATE "accounts"
SET first_name = $2,
last_name = $3,
user_name = $4,
    password = $5,
    status = $6,
is_approved = $7,
    signup_token = NULL,
    signup_token_expires_at = NULL,
    updated_at = now(),
    last_active = now()
WHERE id = $1
RETURNING id, first_name, last_name, user_name, email, department, password, status, role, is_2fa_enabled, signup_token, signup_token_expires_at, otp_code, otp_expires_at, is_approved, created_at, last_active, updated_at, profile_url
`

type UpdateAccountSetupParams struct {
	ID         uuid.UUID   `json:"id"`
	FirstName  pgtype.Text `json:"first_name"`
	LastName   pgtype.Text `json:"last_name"`
	UserName   pgtype.Text `json:"user_name"`
	Password   pgtype.Text `json:"password"`
	Status     string      `json:"status"`
	IsApproved bool        `json:"is_approved"`
}

func (q *Queries) UpdateAccountSetup(ctx context.Context, arg UpdateAccountSetupParams) (Accounts, error) {
	row := q.db.QueryRow(ctx, updateAccountSetup,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.UserName,
		arg.Password,
		arg.Status,
		arg.IsApproved,
	)
	var i Accounts
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.UserName,
		&i.Email,
		&i.Department,
		&i.Password,
		&i.Status,
		&i.Role,
		&i.Is2faEnabled,
		&i.SignupToken,
		&i.SignupTokenExpiresAt,
		&i.OtpCode,
		&i.OtpExpiresAt,
		&i.IsApproved,
		&i.CreatedAt,
		&i.LastActive,
		&i.UpdatedAt,
		&i.ProfileUrl,
	)
	return i, err
}

const updateAccountStatus = `-- name: UpdateAccountStatus :one
UPDATE "accounts"
SET status = $2,
    updated_at = now()
WHERE id = $1
RETURNING id, first_name, last_name, user_name, email, department, password, status, role, is_2fa_enabled, signup_token, signup_token_expires_at, otp_code, otp_expires_at, is_approved, created_at, last_active, updated_at, profile_url
`

type UpdateAccountStatusParams struct {
	ID     uuid.UUID `json:"id"`
	Status string    `json:"status"`
}

func (q *Queries) UpdateAccountStatus(ctx context.Context, arg UpdateAccountStatusParams) (Accounts, error) {
	row := q.db.QueryRow(ctx, updateAccountStatus, arg.ID, arg.Status)
	var i Accounts
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.UserName,
		&i.Email,
		&i.Department,
		&i.Password,
		&i.Status,
		&i.Role,
		&i.Is2faEnabled,
		&i.SignupToken,
		&i.SignupTokenExpiresAt,
		&i.OtpCode,
		&i.OtpExpiresAt,
		&i.IsApproved,
		&i.CreatedAt,
		&i.LastActive,
		&i.UpdatedAt,
		&i.ProfileUrl,
	)
	return i, err
}
