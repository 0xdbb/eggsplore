// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: accounts.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const clearAccountOTP = `-- name: ClearAccountOTP :exec
UPDATE "accounts"
SET otp_code = NULL,
    otp_expires_at = NULL,
    updated_at = now()
WHERE id = $1
`

func (q *Queries) ClearAccountOTP(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, clearAccountOTP, id)
	return err
}

const createAccount = `-- name: CreateAccount :one
INSERT INTO "accounts" (
    email, password, first_name, last_name, username  
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING id, first_name, last_name, username, email, password, profile_url, status, role, is_2fa_enabled, otp_code, otp_expires_at, is_approved, is_verified, created_at, last_active, updated_at
`

type CreateAccountParams struct {
	Email     string      `json:"email"`
	Password  string      `json:"password"`
	FirstName pgtype.Text `json:"first_name"`
	LastName  pgtype.Text `json:"last_name"`
	Username  pgtype.Text `json:"username"`
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) (Accounts, error) {
	row := q.db.QueryRow(ctx, createAccount,
		arg.Email,
		arg.Password,
		arg.FirstName,
		arg.LastName,
		arg.Username,
	)
	var i Accounts
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.ProfileUrl,
		&i.Status,
		&i.Role,
		&i.Is2faEnabled,
		&i.OtpCode,
		&i.OtpExpiresAt,
		&i.IsApproved,
		&i.IsVerified,
		&i.CreatedAt,
		&i.LastActive,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAccount = `-- name: DeleteAccount :exec
DELETE FROM "accounts"
WHERE id = $1
`

func (q *Queries) DeleteAccount(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAccount, id)
	return err
}

const getAccount = `-- name: GetAccount :one
SELECT id, first_name, last_name, username, email, password, profile_url, status, role, is_2fa_enabled, otp_code, otp_expires_at, is_approved, is_verified, created_at, last_active, updated_at FROM "accounts"
WHERE id = $1
`

func (q *Queries) GetAccount(ctx context.Context, id uuid.UUID) (Accounts, error) {
	row := q.db.QueryRow(ctx, getAccount, id)
	var i Accounts
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.ProfileUrl,
		&i.Status,
		&i.Role,
		&i.Is2faEnabled,
		&i.OtpCode,
		&i.OtpExpiresAt,
		&i.IsApproved,
		&i.IsVerified,
		&i.CreatedAt,
		&i.LastActive,
		&i.UpdatedAt,
	)
	return i, err
}

const getAccountByEmail = `-- name: GetAccountByEmail :one
SELECT id, first_name, last_name, username, email, password, profile_url, status, role, is_2fa_enabled, otp_code, otp_expires_at, is_approved, is_verified, created_at, last_active, updated_at FROM "accounts"
WHERE LOWER(email) = LOWER($1)
`

func (q *Queries) GetAccountByEmail(ctx context.Context, lower string) (Accounts, error) {
	row := q.db.QueryRow(ctx, getAccountByEmail, lower)
	var i Accounts
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.ProfileUrl,
		&i.Status,
		&i.Role,
		&i.Is2faEnabled,
		&i.OtpCode,
		&i.OtpExpiresAt,
		&i.IsApproved,
		&i.IsVerified,
		&i.CreatedAt,
		&i.LastActive,
		&i.UpdatedAt,
	)
	return i, err
}

const getAccountMetrics = `-- name: GetAccountMetrics :one
SELECT
    COUNT(*) AS total_accounts,
    SUM(CASE WHEN status = 'ACTIVE' THEN 1 ELSE 0 END) AS active_users,
    SUM(CASE WHEN status = 'INACTIVE' THEN 1 ELSE 0 END) AS inactive_users,
    SUM(CASE WHEN status = 'PENDING' THEN 1 ELSE 0 END) AS pending_invites
FROM accounts
`

type GetAccountMetricsRow struct {
	TotalAccounts  int64 `json:"total_accounts"`
	ActiveUsers    int64 `json:"active_users"`
	InactiveUsers  int64 `json:"inactive_users"`
	PendingInvites int64 `json:"pending_invites"`
}

func (q *Queries) GetAccountMetrics(ctx context.Context) (GetAccountMetricsRow, error) {
	row := q.db.QueryRow(ctx, getAccountMetrics)
	var i GetAccountMetricsRow
	err := row.Scan(
		&i.TotalAccounts,
		&i.ActiveUsers,
		&i.InactiveUsers,
		&i.PendingInvites,
	)
	return i, err
}

const getProfile = `-- name: GetProfile :one
SELECT id, first_name, last_name, username, profile_url, email,  role, is_2fa_enabled, is_approved, password
FROM accounts
WHERE id = $1
`

type GetProfileRow struct {
	ID           uuid.UUID   `json:"id"`
	FirstName    pgtype.Text `json:"first_name"`
	LastName     pgtype.Text `json:"last_name"`
	Username     pgtype.Text `json:"username"`
	ProfileUrl   pgtype.Text `json:"profile_url"`
	Email        string      `json:"email"`
	Role         string      `json:"role"`
	Is2faEnabled pgtype.Bool `json:"is_2fa_enabled"`
	IsApproved   bool        `json:"is_approved"`
	Password     string      `json:"password"`
}

func (q *Queries) GetProfile(ctx context.Context, id uuid.UUID) (GetProfileRow, error) {
	row := q.db.QueryRow(ctx, getProfile, id)
	var i GetProfileRow
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Username,
		&i.ProfileUrl,
		&i.Email,
		&i.Role,
		&i.Is2faEnabled,
		&i.IsApproved,
		&i.Password,
	)
	return i, err
}

const listAccounts = `-- name: ListAccounts :many
SELECT id, first_name, last_name, username, email, password, profile_url, status, role, is_2fa_enabled, otp_code, otp_expires_at, is_approved, is_verified, created_at, last_active, updated_at
FROM accounts
WHERE
  (($3::varchar IS NULL OR $3::varchar = '') OR role::varchar = $3::varchar)
AND (($4::varchar IS NULL OR $4::varchar = '') OR status::varchar = $4::varchar)
LIMIT $1 OFFSET $2
`

type ListAccountsParams struct {
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
	Role   string `json:"role"`
	Status string `json:"status"`
}

func (q *Queries) ListAccounts(ctx context.Context, arg ListAccountsParams) ([]Accounts, error) {
	rows, err := q.db.Query(ctx, listAccounts,
		arg.Limit,
		arg.Offset,
		arg.Role,
		arg.Status,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Accounts{}
	for rows.Next() {
		var i Accounts
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Username,
			&i.Email,
			&i.Password,
			&i.ProfileUrl,
			&i.Status,
			&i.Role,
			&i.Is2faEnabled,
			&i.OtpCode,
			&i.OtpExpiresAt,
			&i.IsApproved,
			&i.IsVerified,
			&i.CreatedAt,
			&i.LastActive,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAccountLastActive = `-- name: UpdateAccountLastActive :exec
UPDATE "accounts"
SET last_active = now()
WHERE id = $1
`

func (q *Queries) UpdateAccountLastActive(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, updateAccountLastActive, id)
	return err
}

const updateAccountOTP = `-- name: UpdateAccountOTP :exec
UPDATE "accounts"
SET otp_code = $2,
    otp_expires_at = $3,
    updated_at = now()
WHERE id = $1
`

type UpdateAccountOTPParams struct {
	ID           uuid.UUID   `json:"id"`
	OtpCode      pgtype.Text `json:"otp_code"`
	OtpExpiresAt pgtype.Text `json:"otp_expires_at"`
}

func (q *Queries) UpdateAccountOTP(ctx context.Context, arg UpdateAccountOTPParams) error {
	_, err := q.db.Exec(ctx, updateAccountOTP, arg.ID, arg.OtpCode, arg.OtpExpiresAt)
	return err
}

const updateAccountPassword = `-- name: UpdateAccountPassword :one
UPDATE "accounts"
SET password = $2,
    updated_at = now()
WHERE id = $1
RETURNING id, first_name, last_name, username, email, password, profile_url, status, role, is_2fa_enabled, otp_code, otp_expires_at, is_approved, is_verified, created_at, last_active, updated_at
`

type UpdateAccountPasswordParams struct {
	ID       uuid.UUID `json:"id"`
	Password string    `json:"password"`
}

func (q *Queries) UpdateAccountPassword(ctx context.Context, arg UpdateAccountPasswordParams) (Accounts, error) {
	row := q.db.QueryRow(ctx, updateAccountPassword, arg.ID, arg.Password)
	var i Accounts
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.ProfileUrl,
		&i.Status,
		&i.Role,
		&i.Is2faEnabled,
		&i.OtpCode,
		&i.OtpExpiresAt,
		&i.IsApproved,
		&i.IsVerified,
		&i.CreatedAt,
		&i.LastActive,
		&i.UpdatedAt,
	)
	return i, err
}

const updateAccountRole = `-- name: UpdateAccountRole :one
UPDATE "accounts"
SET role = $2,
    updated_at = now()
WHERE id = $1
RETURNING id, first_name, last_name, username, email, password, profile_url, status, role, is_2fa_enabled, otp_code, otp_expires_at, is_approved, is_verified, created_at, last_active, updated_at
`

type UpdateAccountRoleParams struct {
	ID   uuid.UUID `json:"id"`
	Role string    `json:"role"`
}

func (q *Queries) UpdateAccountRole(ctx context.Context, arg UpdateAccountRoleParams) (Accounts, error) {
	row := q.db.QueryRow(ctx, updateAccountRole, arg.ID, arg.Role)
	var i Accounts
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.ProfileUrl,
		&i.Status,
		&i.Role,
		&i.Is2faEnabled,
		&i.OtpCode,
		&i.OtpExpiresAt,
		&i.IsApproved,
		&i.IsVerified,
		&i.CreatedAt,
		&i.LastActive,
		&i.UpdatedAt,
	)
	return i, err
}

const updateAccountStatus = `-- name: UpdateAccountStatus :one
UPDATE "accounts"
SET status = $2,
    updated_at = now()
WHERE id = $1
RETURNING id, first_name, last_name, username, email, password, profile_url, status, role, is_2fa_enabled, otp_code, otp_expires_at, is_approved, is_verified, created_at, last_active, updated_at
`

type UpdateAccountStatusParams struct {
	ID     uuid.UUID `json:"id"`
	Status string    `json:"status"`
}

func (q *Queries) UpdateAccountStatus(ctx context.Context, arg UpdateAccountStatusParams) (Accounts, error) {
	row := q.db.QueryRow(ctx, updateAccountStatus, arg.ID, arg.Status)
	var i Accounts
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.ProfileUrl,
		&i.Status,
		&i.Role,
		&i.Is2faEnabled,
		&i.OtpCode,
		&i.OtpExpiresAt,
		&i.IsApproved,
		&i.IsVerified,
		&i.CreatedAt,
		&i.LastActive,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePassword = `-- name: UpdatePassword :exec
UPDATE accounts
SET
    password = $2,
    updated_at = now()
WHERE id = $1
`

type UpdatePasswordParams struct {
	ID       uuid.UUID `json:"id"`
	Password string    `json:"password"`
}

func (q *Queries) UpdatePassword(ctx context.Context, arg UpdatePasswordParams) error {
	_, err := q.db.Exec(ctx, updatePassword, arg.ID, arg.Password)
	return err
}
