// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: game.sql

package database

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addEggDetails = `-- name: AddEggDetails :one
INSERT INTO eggs (inventory_id, type, message, location)
VALUES (
  $1,
  $2,
  $3,
  ST_SetSRID(ST_MakePoint($4::float, $5::float), 4326)
)
RETURNING inventory_id, hatched, type, message, collected_at
`

type AddEggDetailsParams struct {
	InventoryID uuid.UUID   `json:"inventory_id"`
	Type        string      `json:"type"`
	Message     pgtype.Text `json:"message"`
	Lon         float64     `json:"lon"`
	Lat         float64     `json:"lat"`
}

func (q *Queries) AddEggDetails(ctx context.Context, arg AddEggDetailsParams) (Eggs, error) {
	row := q.db.QueryRow(ctx, addEggDetails,
		arg.InventoryID,
		arg.Type,
		arg.Message,
		arg.Lon,
		arg.Lat,
	)
	var i Eggs
	err := row.Scan(
		&i.InventoryID,
		&i.Hatched,
		&i.Type,
		&i.Message,
		&i.CollectedAt,
	)
	return i, err
}

const createEgg = `-- name: CreateEgg :one
INSERT INTO inventory (player_id, item_type, quantity, description)
VALUES ($1, 'EGG', 1, $2)
RETURNING id, player_id, item_type, quantity, description, created_at
`

type CreateEggParams struct {
	PlayerID    uuid.UUID   `json:"player_id"`
	Description pgtype.Text `json:"description"`
}

func (q *Queries) CreateEgg(ctx context.Context, arg CreateEggParams) (Inventory, error) {
	row := q.db.QueryRow(ctx, createEgg, arg.PlayerID, arg.Description)
	var i Inventory
	err := row.Scan(
		&i.ID,
		&i.PlayerID,
		&i.ItemType,
		&i.Quantity,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const getEggsByPlayer = `-- name: GetEggsByPlayer :many
SELECT i.id AS inventory_id, e.type, e.hatched, e.message, e.collected_at
FROM inventory i
JOIN eggs e ON e.inventory_id = i.id
WHERE i.player_id = $1
`

type GetEggsByPlayerRow struct {
	InventoryID uuid.UUID   `json:"inventory_id"`
	Type        string      `json:"type"`
	Hatched     pgtype.Bool `json:"hatched"`
	Message     pgtype.Text `json:"message"`
	CollectedAt time.Time   `json:"collected_at"`
}

func (q *Queries) GetEggsByPlayer(ctx context.Context, playerID uuid.UUID) ([]GetEggsByPlayerRow, error) {
	rows, err := q.db.Query(ctx, getEggsByPlayer, playerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEggsByPlayerRow{}
	for rows.Next() {
		var i GetEggsByPlayerRow
		if err := rows.Scan(
			&i.InventoryID,
			&i.Type,
			&i.Hatched,
			&i.Message,
			&i.CollectedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInventoryByPlayer = `-- name: GetInventoryByPlayer :many
SELECT id, player_id, item_type, quantity, description, created_at
FROM inventory
WHERE player_id = $1
`

func (q *Queries) GetInventoryByPlayer(ctx context.Context, playerID uuid.UUID) ([]Inventory, error) {
	rows, err := q.db.Query(ctx, getInventoryByPlayer, playerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Inventory{}
	for rows.Next() {
		var i Inventory
		if err := rows.Scan(
			&i.ID,
			&i.PlayerID,
			&i.ItemType,
			&i.Quantity,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayerByAccount = `-- name: GetPlayerByAccount :one
SELECT id, account_id, coins, xp, level, settings, created_at, updated_at
FROM players
WHERE account_id = $1
`

func (q *Queries) GetPlayerByAccount(ctx context.Context, accountID uuid.UUID) (Players, error) {
	row := q.db.QueryRow(ctx, getPlayerByAccount, accountID)
	var i Players
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.Coins,
		&i.Xp,
		&i.Level,
		&i.Settings,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getToolsByPlayer = `-- name: GetToolsByPlayer :many
SELECT i.id AS inventory_id, t.durability, t.equipped, i.description
FROM inventory i
JOIN tools t ON t.inventory_id = i.id
WHERE i.player_id = $1
`

type GetToolsByPlayerRow struct {
	InventoryID uuid.UUID   `json:"inventory_id"`
	Durability  int32       `json:"durability"`
	Equipped    pgtype.Bool `json:"equipped"`
	Description pgtype.Text `json:"description"`
}

func (q *Queries) GetToolsByPlayer(ctx context.Context, playerID uuid.UUID) ([]GetToolsByPlayerRow, error) {
	rows, err := q.db.Query(ctx, getToolsByPlayer, playerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetToolsByPlayerRow{}
	for rows.Next() {
		var i GetToolsByPlayerRow
		if err := rows.Scan(
			&i.InventoryID,
			&i.Durability,
			&i.Equipped,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePlayerStats = `-- name: UpdatePlayerStats :one
UPDATE players
SET coins = coins + $2,
    xp = xp + $3,
    updated_at = now()
WHERE id = $1
RETURNING id, account_id, coins, xp, level, settings, created_at, updated_at
`

type UpdatePlayerStatsParams struct {
	ID    uuid.UUID `json:"id"`
	Coins int64     `json:"coins"`
	Xp    int64     `json:"xp"`
}

func (q *Queries) UpdatePlayerStats(ctx context.Context, arg UpdatePlayerStatsParams) (Players, error) {
	row := q.db.QueryRow(ctx, updatePlayerStats, arg.ID, arg.Coins, arg.Xp)
	var i Players
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.Coins,
		&i.Xp,
		&i.Level,
		&i.Settings,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
