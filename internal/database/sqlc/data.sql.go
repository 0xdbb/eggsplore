// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: data.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const calculatePriorityIndex = `-- name: CalculatePriorityIndex :many
WITH reports_transformed AS (
    SELECT
        ST_Transform(location, 3857) AS geom,
        'report' AS type,
        1.0 AS weight
    FROM reports
    WHERE created_at >= $1::timestamp
      AND created_at <= $2::timestamp
),
segments_raw AS (
    SELECT
        ST_Centroid(ST_Transform(geom, 3857)) AS geom,
        'segment' AS type,
        ST_Area(ST_Transform(geom, 3857)) AS area
    FROM mining_static
    WHERE detection_date >= $1::timestamp
      AND detection_date <= $2::timestamp
),
area_stats AS (
    SELECT 
        MIN(area) AS min_area,
        MAX(area) AS max_area
    FROM segments_raw
),
segments_transformed AS (
    SELECT
        geom,
        type,
        CASE
            WHEN (area_stats.max_area - area_stats.min_area) = 0 THEN 1.0
            ELSE (s.area - area_stats.min_area) / (area_stats.max_area - area_stats.min_area)
        END AS weight
    FROM segments_raw s, area_stats
)

SELECT
    ST_AsGeoJSON(ST_Transform(geom, 4326))::jsonb AS geometry,
    type,
    weight
FROM reports_transformed

UNION ALL

SELECT
    ST_AsGeoJSON(ST_Transform(geom, 4326))::jsonb AS geometry,
    type,
    weight
FROM segments_transformed
`

type CalculatePriorityIndexParams struct {
	StartDate pgtype.Timestamp `json:"start_date"`
	EndDate   pgtype.Timestamp `json:"end_date"`
}

type CalculatePriorityIndexRow struct {
	Geometry []byte  `json:"geometry"`
	Type     string  `json:"type"`
	Weight   float64 `json:"weight"`
}

// Final SELECT projecting back to 4326
func (q *Queries) CalculatePriorityIndex(ctx context.Context, arg CalculatePriorityIndexParams) ([]CalculatePriorityIndexRow, error) {
	rows, err := q.db.Query(ctx, calculatePriorityIndex, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CalculatePriorityIndexRow{}
	for rows.Next() {
		var i CalculatePriorityIndexRow
		if err := rows.Scan(&i.Geometry, &i.Type, &i.Weight); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listConcessions = `-- name: ListConcessions :many
SELECT name, owner, type, status, assets, start_date, expiry_dat, ST_AsGeoJSON(geom)::jsonb AS geometry
FROM concessions
`

type ListConcessionsRow struct {
	Name      pgtype.Text      `json:"name"`
	Owner     pgtype.Text      `json:"owner"`
	Type      pgtype.Text      `json:"type"`
	Status    pgtype.Text      `json:"status"`
	Assets    pgtype.Text      `json:"assets"`
	StartDate pgtype.Timestamp `json:"start_date"`
	ExpiryDat pgtype.Timestamp `json:"expiry_dat"`
	Geometry  []byte           `json:"geometry"`
}

func (q *Queries) ListConcessions(ctx context.Context) ([]ListConcessionsRow, error) {
	rows, err := q.db.Query(ctx, listConcessions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListConcessionsRow{}
	for rows.Next() {
		var i ListConcessionsRow
		if err := rows.Scan(
			&i.Name,
			&i.Owner,
			&i.Type,
			&i.Status,
			&i.Assets,
			&i.StartDate,
			&i.ExpiryDat,
			&i.Geometry,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDistricts = `-- name: ListDistricts :many
SELECT  district, region, ST_AsGeoJSON(geom)::jsonb AS geometry
FROM districts
`

type ListDistrictsRow struct {
	District pgtype.Text `json:"district"`
	Region   pgtype.Text `json:"region"`
	Geometry []byte      `json:"geometry"`
}

func (q *Queries) ListDistricts(ctx context.Context) ([]ListDistrictsRow, error) {
	rows, err := q.db.Query(ctx, listDistricts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListDistrictsRow{}
	for rows.Next() {
		var i ListDistrictsRow
		if err := rows.Scan(&i.District, &i.Region, &i.Geometry); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDistrictsByName = `-- name: ListDistrictsByName :many
SELECT district
FROM districts
WHERE district ILIKE '%' || $1::text || '%'
`

func (q *Queries) ListDistrictsByName(ctx context.Context, text string) ([]pgtype.Text, error) {
	rows, err := q.db.Query(ctx, listDistrictsByName, text)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []pgtype.Text{}
	for rows.Next() {
		var district pgtype.Text
		if err := rows.Scan(&district); err != nil {
			return nil, err
		}
		items = append(items, district)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFirst10Districts = `-- name: ListFirst10Districts :many
SELECT district
FROM districts
LIMIT 10
`

func (q *Queries) ListFirst10Districts(ctx context.Context) ([]pgtype.Text, error) {
	rows, err := q.db.Query(ctx, listFirst10Districts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []pgtype.Text{}
	for rows.Next() {
		var district pgtype.Text
		if err := rows.Scan(&district); err != nil {
			return nil, err
		}
		items = append(items, district)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listForestReserves = `-- name: ListForestReserves :many
SELECT name, category, ST_AsGeoJSON(geom)::jsonb AS geometry
FROM forest_reserves
`

type ListForestReservesRow struct {
	Name     pgtype.Text `json:"name"`
	Category pgtype.Text `json:"category"`
	Geometry []byte      `json:"geometry"`
}

func (q *Queries) ListForestReserves(ctx context.Context) ([]ListForestReservesRow, error) {
	rows, err := q.db.Query(ctx, listForestReserves)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListForestReservesRow{}
	for rows.Next() {
		var i ListForestReservesRow
		if err := rows.Scan(&i.Name, &i.Category, &i.Geometry); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMiningStatic = `-- name: ListMiningStatic :many
SELECT id, district,severity_type, status, severity_score, severity, all_violation_types, area, proximity_to_water, inside_forest_reserve, distance_to_water_m, distance_to_forest_m,  detection_date, task_id, ST_AsGeoJSON(geom)::jsonb AS geometry
FROM mining_static
`

type ListMiningStaticRow struct {
	ID                  string           `json:"id"`
	District            pgtype.Text      `json:"district"`
	SeverityType        pgtype.Text      `json:"severity_type"`
	Status              pgtype.Text      `json:"status"`
	SeverityScore       pgtype.Int8      `json:"severity_score"`
	Severity            pgtype.Text      `json:"severity"`
	AllViolationTypes   pgtype.Text      `json:"all_violation_types"`
	Area                pgtype.Float8    `json:"area"`
	ProximityToWater    pgtype.Bool      `json:"proximity_to_water"`
	InsideForestReserve pgtype.Bool      `json:"inside_forest_reserve"`
	DistanceToWaterM    pgtype.Float8    `json:"distance_to_water_m"`
	DistanceToForestM   pgtype.Float8    `json:"distance_to_forest_m"`
	DetectionDate       pgtype.Timestamp `json:"detection_date"`
	TaskID              uuid.UUID        `json:"task_id"`
	Geometry            []byte           `json:"geometry"`
}

func (q *Queries) ListMiningStatic(ctx context.Context) ([]ListMiningStaticRow, error) {
	rows, err := q.db.Query(ctx, listMiningStatic)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListMiningStaticRow{}
	for rows.Next() {
		var i ListMiningStaticRow
		if err := rows.Scan(
			&i.ID,
			&i.District,
			&i.SeverityType,
			&i.Status,
			&i.SeverityScore,
			&i.Severity,
			&i.AllViolationTypes,
			&i.Area,
			&i.ProximityToWater,
			&i.InsideForestReserve,
			&i.DistanceToWaterM,
			&i.DistanceToForestM,
			&i.DetectionDate,
			&i.TaskID,
			&i.Geometry,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRivers = `-- name: ListRivers :many
SELECT ST_AsGeoJSON(geom)::jsonb AS geometry
FROM rivers
`

func (q *Queries) ListRivers(ctx context.Context) ([][]byte, error) {
	rows, err := q.db.Query(ctx, listRivers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := [][]byte{}
	for rows.Next() {
		var geometry []byte
		if err := rows.Scan(&geometry); err != nil {
			return nil, err
		}
		items = append(items, geometry)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMiningStaticStatus = `-- name: UpdateMiningStaticStatus :one
UPDATE mining_static
SET status = $1
WHERE id = $2
RETURNING id, district, status, severity_type, severity_score, severity, all_violation_types, area, proximity_to_water, inside_forest_reserve, distance_to_water_m, distance_to_forest_m, detection_date, ST_AsGeoJSON(geom)::jsonb AS geometry
`

type UpdateMiningStaticStatusParams struct {
	Status pgtype.Text `json:"status"`
	ID     string      `json:"id"`
}

type UpdateMiningStaticStatusRow struct {
	ID                  string           `json:"id"`
	District            pgtype.Text      `json:"district"`
	Status              pgtype.Text      `json:"status"`
	SeverityType        pgtype.Text      `json:"severity_type"`
	SeverityScore       pgtype.Int8      `json:"severity_score"`
	Severity            pgtype.Text      `json:"severity"`
	AllViolationTypes   pgtype.Text      `json:"all_violation_types"`
	Area                pgtype.Float8    `json:"area"`
	ProximityToWater    pgtype.Bool      `json:"proximity_to_water"`
	InsideForestReserve pgtype.Bool      `json:"inside_forest_reserve"`
	DistanceToWaterM    pgtype.Float8    `json:"distance_to_water_m"`
	DistanceToForestM   pgtype.Float8    `json:"distance_to_forest_m"`
	DetectionDate       pgtype.Timestamp `json:"detection_date"`
	Geometry            []byte           `json:"geometry"`
}

func (q *Queries) UpdateMiningStaticStatus(ctx context.Context, arg UpdateMiningStaticStatusParams) (UpdateMiningStaticStatusRow, error) {
	row := q.db.QueryRow(ctx, updateMiningStaticStatus, arg.Status, arg.ID)
	var i UpdateMiningStaticStatusRow
	err := row.Scan(
		&i.ID,
		&i.District,
		&i.Status,
		&i.SeverityType,
		&i.SeverityScore,
		&i.Severity,
		&i.AllViolationTypes,
		&i.Area,
		&i.ProximityToWater,
		&i.InsideForestReserve,
		&i.DistanceToWaterM,
		&i.DistanceToForestM,
		&i.DetectionDate,
		&i.Geometry,
	)
	return i, err
}
